package si.nejcj.goalball.scoresheet.db;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import javax.swing.JOptionPane;

import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.BeanHandler;
import org.apache.commons.dbutils.handlers.BeanListHandler;
import org.hsqldb.jdbc.jdbcDataSource;

import si.nejcj.goalball.scoresheet.db.entity.GameScore;
import si.nejcj.goalball.scoresheet.db.entity.Official;
import si.nejcj.goalball.scoresheet.db.entity.OfficialLevel;
import si.nejcj.goalball.scoresheet.db.entity.Player;
import si.nejcj.goalball.scoresheet.db.entity.Staff;
import si.nejcj.goalball.scoresheet.db.entity.Team;
import si.nejcj.goalball.scoresheet.db.entity.Tournament;
import si.nejcj.goalball.scoresheet.db.entity.TournamentGame;
import si.nejcj.goalball.scoresheet.db.entity.TournamentOfficial;
import si.nejcj.goalball.scoresheet.db.entity.TournamentPlayer;
import si.nejcj.goalball.scoresheet.db.entity.TournamentStaff;
import si.nejcj.goalball.scoresheet.db.entity.TournamentTeam;
import si.nejcj.goalball.scoresheet.db.entity.util.RefereeGame;
import si.nejcj.goalball.scoresheet.db.entity.util.RefereeStats;
import si.nejcj.goalball.scoresheet.db.entity.util.TournamentStatsType;
import si.nejcj.goalball.scoresheet.exception.business.InternalBusinessException;
import si.nejcj.goalball.scoresheet.exception.business.InternalIntegrityConstraintException;
import si.nejcj.goalball.scoresheet.exception.technical.InternalTechnicalException;
import si.nejcj.goalball.scoresheet.util.Constants;
import si.nejcj.goalball.scoresheet.util.IntegerListHandler;

public class DatabaseConnection {

  // CORRECT THIS FIELD EVERYTIME THERE IS A CHANGE TO DATABASE STRUCTURE
  private static final int DATABASE_VERSION = 5;

  private Connection m_connection;
  private Statement m_statement = null;
  private QueryRunner queryRunner;

  /**
   * Creates a new database connection.
   * 
   * @param userHomeDirectory
   *          Home directory of current user. Database .script file is saved in
   *          this directory.
   * @throws InternalTechnicalException
   *           If problems arise establishing db connection.
   */
  public DatabaseConnection(String userHomeDirectory) {
    try {
      jdbcDataSource dataSource = new jdbcDataSource();
      dataSource.setDatabase(
          "jdbc:hsqldb:" + userHomeDirectory + "/GoalballScoreSheet");
      dataSource.setUser("sa");
      dataSource.setPassword("");
      queryRunner = new QueryRunner(dataSource);
      m_connection = dataSource.getConnection();
      m_statement = m_connection.createStatement();

      createTables();
      alterTables();
      insertBasicData();
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Problem establishing database connection.", e);
    }
  }

  /**
   * Closes the current connection.
   * 
   * @throws InternalTechnicalException
   *           If problems arise during closing of db connection.
   */
  public void close() {
    try {
      m_statement.execute("SHUTDOWN"); // make sure, that all data is flushed to
                                       // disk
      m_connection.close();
    } catch (SQLException ex) {
      throw new InternalTechnicalException("Can not close database connection.",
          ex);
    }
  }

  /**
   * Creates tables. Only tables that were in original design of the database
   * are created here. The rest are created in alterTables().
   * 
   * @throws InternalTechnicalException
   */
  private void createTables() {
    /* COUNTRY */
    try {
      m_statement.executeQuery(
          "CREATE TABLE country (country_name varchar(64) PRIMARY KEY)");
    } catch (SQLException e) {
      if (!e.getMessage().startsWith("Table already exists")) {
        throw new InternalTechnicalException(e);
      }
    }
    /* TEAM */
    try {
      m_statement.executeQuery("CREATE TABLE team "
          + "(id INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1, INCREMENT BY 1)PRIMARY KEY, "
          + "team_name varchar(64), " + "admin_data boolean,"
          + "national_team boolean," + "country varchar(64),"
          + "CONSTRAINT team_country_fk FOREIGN KEY (country) REFERENCES country(country_name))");
    } catch (SQLException e) {
      if (!e.getMessage().startsWith("Table already exists")) {
        throw new InternalTechnicalException(e);
      }
    }
    /* STAFF */
    try {
      m_statement.executeQuery("CREATE TABLE staff "
          + "(id INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1, INCREMENT BY 1)PRIMARY KEY, "
          + "last_name varchar(32), " + "first_name varchar(32), "
          + "person_position varchar (64), " + "team_id INTEGER, "
          + "admin_data boolean, "
          + "CONSTRAINT staff_team_fk FOREIGN KEY (team_id) REFERENCES team(id))");
    } catch (SQLException e) {
      if (!e.getMessage().startsWith("Table already exists")) {
        throw new InternalTechnicalException(e);
      }
    }
    /* PLAYER */
    try {
      m_statement.executeQuery("CREATE TABLE player "
          + "(id INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1, INCREMENT BY 1)PRIMARY KEY, "
          + "last_name varchar(32), " + "first_name varchar(32), "
          + "team_id INTEGER, " + "admin_data boolean, "
          + "CONSTRAINT player_team_fk FOREIGN KEY (team_id) REFERENCES team(id))");
    } catch (SQLException e) {
      if (!e.getMessage().startsWith("Table already exists")) {
        throw new InternalTechnicalException(e);
      }
    }
    /* OFFICIAL_LEVEL */
    try {
      m_statement.executeQuery("CREATE TABLE official_level "
          + "(id INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1, INCREMENT BY 1)PRIMARY KEY, "
          + "level_name varchar(32), " + "level_description varchar(64), "
          + "admin_data boolean, "
          + "CONSTRAINT unique_level UNIQUE (level_name))");
    } catch (SQLException e) {
      if (!e.getMessage().startsWith("Table already exists")) {
        throw new InternalTechnicalException(e);
      }
    }
    /* OFFICIAL */
    try {
      m_statement.executeQuery("CREATE TABLE official "
          + "(id INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1, INCREMENT BY 1)PRIMARY KEY, "
          + "last_name varchar(32), " + "first_name varchar(32), "
          + "gender varchar(16), " + "official_level_id INTEGER, "
          + "country varchar(64), " + "admin_data boolean, "
          + "CONSTRAINT level_fk FOREIGN KEY (official_level_id) REFERENCES official_level(id), "
          + "CONSTRAINT official_country_fk FOREIGN KEY (country) REFERENCES country(country_name))");
    } catch (SQLException e) {
      if (!e.getMessage().startsWith("Table already exists")) {
        throw new InternalTechnicalException(e);
      }
    }
    /* TOURNAMENT */
    try {
      m_statement.executeQuery("CREATE TABLE tournament "
          + "(id INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1, INCREMENT BY 1)PRIMARY KEY, "
          + "tournament_name varchar(128), "
          + "tournament_location varchar(128), " + "start_date date, "
          + "end_date date)");
    } catch (SQLException e) {
      if (!e.getMessage().startsWith("Table already exists")) {
        throw new InternalTechnicalException(e);
      }
    }
    /* TOURNAMENT_OFFICIAL */
    try {
      m_statement.executeQuery("CREATE TABLE tournament_official "
          + "(id INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1, INCREMENT BY 1)PRIMARY KEY, "
          + "tournament_id integer, " + "official_id integer, "
          + "CONSTRAINT tournament_official_tournament_fk FOREIGN KEY (tournament_id) REFERENCES tournament(id), "
          + "CONSTRAINT tournament_official_official_fk FOREIGN KEY (official_id) REFERENCES official(id))");
    } catch (SQLException e) {
      if (!e.getMessage().startsWith("Table already exists")) {
        throw new InternalTechnicalException(e);
      }
    }
    /* TOURNAMENT_TEAM */
    try {
      m_statement.executeQuery("CREATE TABLE tournament_team "
          + "(id INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1, INCREMENT BY 1)PRIMARY KEY, "
          + "team_id integer, " + "tournament_id integer, "
          + "CONSTRAINT tournament_team_tournament_fk FOREIGN KEY (tournament_id) REFERENCES tournament(id), "
          + "CONSTRAINT tournament_team_team_fk FOREIGN KEY (team_id) REFERENCES team(id))");
    } catch (SQLException e) {
      if (!e.getMessage().startsWith("Table already exists")) {
        throw new InternalTechnicalException(e);
      }
    }
    /* TOURNAMENT_PLAYER */
    try {
      m_statement.executeQuery("CREATE TABLE tournament_player "
          + "(id INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1, INCREMENT BY 1)PRIMARY KEY, "
          + "player_id integer, " + "tournament_team_id integer, "
          + "player_number integer, "
          + "CONSTRAINT tournament_player_tournament_team_fk FOREIGN KEY (tournament_team_id) REFERENCES tournament_team(id), "
          + "CONSTRAINT tournament_player_player_fk FOREIGN KEY (player_id) REFERENCES player(id))");
    } catch (SQLException e) {
      if (!e.getMessage().startsWith("Table already exists")) {
        throw new InternalTechnicalException(e);
      }
    }
    /* TOURNAMENT_STAFF */
    try {
      m_statement.executeQuery("CREATE TABLE tournament_staff"
          + "(id INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1, INCREMENT BY 1)PRIMARY KEY, "
          + "staff_id integer, " + "tournament_team_id integer, "
          + "CONSTRAINT tournament_staff_tournament_team_fk FOREIGN KEY (tournament_team_id) REFERENCES tournament_team(id), "
          + "CONSTRAINT tournament_staff_staff_fk FOREIGN KEY (staff_id) REFERENCES staff(id))");
    } catch (SQLException e) {
      if (!e.getMessage().startsWith("Table already exists")) {
        throw new InternalTechnicalException(e);
      }
    }
    /* TOURNAMENT_GAME */
    try {
      m_statement.executeQuery("CREATE TABLE tournament_game "
          + "(id INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1, INCREMENT BY 1)PRIMARY KEY, "
          + "tournament_id integer, " + "game_no integer, " + "game_date date, "
          + "game_time varchar(5), " + "pool varchar(16), "
          + "venue varchar(128), " + "gender varchar(6), "
          + "needs_winner boolean default false, " + "team_a_id integer, "
          + "team_b_id integer, " + "referee_1_id integer, "
          + "referee_2_id integer, " + "ten_sec_1_id integer, "
          + "ten_sec_2_id integer, " + "scorer_id integer, "
          + "shot_recorder_id integer, " + "timer_id integer, "
          + "backup_timer_id integer, " + "goal_judge_1_id integer, "
          + "goal_judge_2_id integer, " + "goal_judge_3_id integer, "
          + "goal_judge_4_id integer, "
          + "CONSTRAINT tournament_game_tournament_fk FOREIGN KEY (tournament_id) REFERENCES tournament(id), "
          + "CONSTRAINT tournament_game_team_a_fk FOREIGN KEY (team_a_id) REFERENCES tournament_team(id), "
          + "CONSTRAINT tournament_game_team_b_fk FOREIGN KEY (team_b_id) REFERENCES tournament_team(id), "
          + "CONSTRAINT tournament_game_ref_1_fk FOREIGN KEY (referee_1_id) REFERENCES tournament_official(id), "
          + "CONSTRAINT tournament_game_ref_2_fk FOREIGN KEY (referee_2_id) REFERENCES tournament_official(id), "
          + "CONSTRAINT tournament_game_ten_sec_1_fk FOREIGN KEY (ten_sec_1_id) REFERENCES tournament_official(id), "
          + "CONSTRAINT tournament_game_ten_sec_2_fk FOREIGN KEY (ten_sec_2_id) REFERENCES tournament_official(id), "
          + "CONSTRAINT tournament_game_scorer_fk FOREIGN KEY (scorer_id) REFERENCES tournament_official(id), "
          + "CONSTRAINT tournament_game_shot_recorder_fk FOREIGN KEY (shot_recorder_id) REFERENCES tournament_official(id), "
          + "CONSTRAINT tournament_game_timer_fk FOREIGN KEY (timer_id) REFERENCES tournament_official(id), "
          + "CONSTRAINT tournament_game_backup_timer_fk FOREIGN KEY (backup_timer_id) REFERENCES tournament_official(id), "
          + "CONSTRAINT tournament_game_goal_judge_1 FOREIGN KEY (goal_judge_1_id) REFERENCES tournament_official(id),"
          + "CONSTRAINT tournament_game_goal_judge_2 FOREIGN KEY (goal_judge_2_id) REFERENCES tournament_official(id),"
          + "CONSTRAINT tournament_game_goal_judge_3 FOREIGN KEY (goal_judge_3_id) REFERENCES tournament_official(id),"
          + "CONSTRAINT tournament_game_goal_judge_4 FOREIGN KEY (goal_judge_4_id) REFERENCES tournament_official(id))");
    } catch (SQLException e) {
      if (!e.getMessage().startsWith("Table already exists")) {
        throw new InternalTechnicalException(e);
      }
    }
    /* CONFIGURATION */
    try {
      m_statement.executeQuery(
          "CREATE TABLE configuration (key varchar(32) PRIMARY KEY, value varchar(32))");
    } catch (SQLException e) {
      if (!e.getMessage().startsWith("Table already exists")) {
        throw new InternalTechnicalException(e);
      }
    }
  }

  /**
   * Alters tables. This method is used to make changes to the database
   * structure once the database was already created.
   * 
   */
  private void alterTables() {
    int version = getAndSetDatabaseVersion();

    // String query = "";
    switch (version) {

    // case 0:
    // try {
    // query = "INSERT INTO map VALUES (1,142,113)";
    // m_statement.executeQuery(query);
    // query = "INSERT INTO map VALUES (2,142,113)";
    // m_statement.executeQuery(query);
    // query = "INSERT INTO map VALUES (3,142,113)";
    // m_statement.executeQuery(query);
    // } catch (SQLException e) {
    // JOptionPane.showMessageDialog(null, e.getMessage(),
    // "SQLException! method: alterTables(), case 0",
    // JOptionPane.ERROR_MESSAGE);
    // }
    //
    // case 1:
    // try {
    // query = "ALTER TABLE map ADD COLUMN image_name varchar(32)";
    // m_statement.executeQuery(query);
    // query = "ALTER TABLE map ADD COLUMN map_name varchar(32)";
    // m_statement.executeQuery(query);
    // query = "UPDATE map SET map_name='Europe' WHERE id=1";
    // m_statement.executeQuery(query);
    // query = "UPDATE map SET image_name='Europe.jpg' WHERE id=1";
    // m_statement.executeQuery(query);
    // query = "UPDATE map SET map_name='USA' WHERE id=2";
    // m_statement.executeQuery(query);
    // query = "UPDATE map SET image_name='USA.jpg' WHERE id=2";
    // m_statement.executeQuery(query);
    // query = "UPDATE map SET map_name='World' WHERE id=3";
    // m_statement.executeQuery(query);
    // query = "UPDATE map SET image_name='World.jpg' WHERE id=3";
    // m_statement.executeQuery(query);
    // } catch (SQLException e) {
    // JOptionPane.showMessageDialog(null, e.getMessage(),
    // "SQLException! method: alterTables(), case 1",
    // JOptionPane.ERROR_MESSAGE);
    // }
    // case 2:
    // try {
    // String query =
    // "ALTER TABLE tournament_game ADD COLUMN needs_winner boolean default
    // false";
    // m_statement.executeUpdate(query);
    // } catch (SQLException e) {
    // JOptionPane.showMessageDialog(null, e.getMessage(),
    // "SQLException! method: alterTables(), case 2",
    // JOptionPane.ERROR_MESSAGE);
    // }
    case 3:
      try {
        String query = "ALTER TABLE tournament_game ADD COLUMN score_team_a integer default null";
        m_statement.executeUpdate(query);
        query = "ALTER TABLE tournament_game ADD COLUMN score_team_b integer default null";
        m_statement.executeUpdate(query);

        query = "CREATE TABLE game_score "
            + "(id INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1, INCREMENT BY 1)PRIMARY KEY, "
            + "game_id integer, " + "tournament_player_id integer, "
            + "no_of_goals integer, "
            + "CONSTRAINT tournament_game_fk FOREIGN KEY (game_id) REFERENCES tournament_game(id), "
            + "CONSTRAINT tournament_player_fk FOREIGN KEY (tournament_player_id) REFERENCES tournament_player(id))";
        m_statement.executeQuery(query);
      } catch (SQLException e) {
        JOptionPane.showMessageDialog(null, e.getMessage(),
            "SQLException! method: alterTables(), case 4",
            JOptionPane.ERROR_MESSAGE);
      }
      break;
    case 4:
      try {
        // Add gender to team data - 0-male, 1-female
        String query = "ALTER TABLE team ADD COLUMN is_male boolean default true";
        m_statement.executeUpdate(query);
      } catch (SQLException e) {
        JOptionPane.showMessageDialog(null, e.getMessage(),
            "SQLException! method: alterTables(), case 4",
            JOptionPane.ERROR_MESSAGE);
      }
      // WHEN ADDING ANY MORE CASES BE SURE TO CORRECT THE VALUE OF
      // DATABASE VERSION TO A HIGHER NUMBER (ONE HIGHER THAN THE LAST CASE)!!!!
    default:
      break;
    }
  }

  /**
   * Gets the current version of the database and sets the new value. The new
   * value is set to the value of local variable DATABASE_VERSION.
   * 
   * @return Current version of database.
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  private int getAndSetDatabaseVersion() {
    int version = 0;
    try {
      String versionStr = getConfiguration("databaseVersion");
      try {
        version = Integer.parseInt(versionStr);
      } catch (NumberFormatException e) {
        // No action necessary.
      }
    } catch (InternalTechnicalException e) {
      // No action necessary
    }
    try {
      updateOrAddConfiguration("databaseVersion",
          String.valueOf(DATABASE_VERSION));
    } catch (InternalTechnicalException e) {
      // No action necessary
    }
    return version;
  }

  /**
   * Returns a list of all teams.
   * 
   * @return List of all teams.
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public List<Team> getAllTeams() {
    String query = "SELECT id, country, team_name as teamname, national_team as nationalteam, is_male as male FROM team";
    try {
      return queryRunner.query(query, new BeanListHandler<Team>(Team.class));
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving teams from database", e);
    }
  }

  /**
   * Returns a list of teams from the database.
   * 
   * @param nationalTeam
   *          Flag indicating if national or non-national teams should be
   *          returned.
   * @return List of teams.
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public List<Team> getTeams(boolean nationalTeam) {
    String query = "SELECT id, team_name as teamname, country, national_team as nationalteam, is_male as male FROM team WHERE national_team = ?";
    try {
      return queryRunner.query(query, new BeanListHandler<Team>(Team.class),
          nationalTeam);
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving teams from database", e);
    }
  }

  /**
   * Returns a list of all official levels.
   * 
   * @return List of all official levels.
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public List<OfficialLevel> getAllOfficialLevels() {
    String query = "SELECT id, level_name as levelname, level_description as leveldescription FROM official_level";

    try {
      return queryRunner.query(query,
          new BeanListHandler<OfficialLevel>(OfficialLevel.class));
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving official levels from database", e);
    }
  }

  /**
   * Returns a list of all officials (including ITOs)
   * 
   * @return List of all officials
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public List<Official> getAllOfficials() {
    return getOfficialsByMinLevel(Constants.OFFICIAL_LEVEL_ITO);
  }

  /**
   * Returns a list of all tournaments
   * 
   * @return List of all tournaments
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public List<Tournament> getAllTournaments() {
    String query = "SELECT id, tournament_name as tournamentName, tournament_location as location, start_date as startDate, end_date as endDate FROM tournament";
    try {
      return queryRunner.query(query,
          new BeanListHandler<Tournament>(Tournament.class));
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving tournaments from database", e);
    }
  }

  /**
   * Returns a list of all officials with level higher than the specified min
   * level.
   * 
   * @param minLevelId
   *          Min level officials must have.
   * @return List of official's with level greater than min level. Level should
   *         be one of the levels specified in {@link Constants}.
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public List<Official> getOfficialsByMinLevel(Integer minLevelId) {
    List<Official> officials = new ArrayList<Official>();
    for (int currentLevel = minLevelId; currentLevel <= Constants.OFFICIAL_LEVEL_III; currentLevel++) {
      officials.addAll(getOfficialsByLevel(currentLevel));
    }
    return officials;
  }

  /**
   * Returns a list of all officials with the given level.
   * 
   * @param levelId
   *          Level officials must have.
   * @return List of officials with the given level. Level should be on of the
   *         levels specified in {@link Constants}.
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public List<Official> getOfficialsByLevel(Integer levelId) {
    String query = "SELECT * FROM official WHERE official_level_id = ?";
    List<Integer> params = new ArrayList<Integer>();
    params.add(levelId);

    try {
      ResultSet rs = executeQuery(query, params);
      List<Official> officials = new ArrayList<Official>();

      while (rs.next()) {
        int id = rs.getInt("id");
        String lastName = rs.getString("last_name");
        String firstName = rs.getString("first_name");
        String gender = rs.getString("gender");
        String country = rs.getString("country");
        int officialLevelId = rs.getInt("official_level_id");
        officials.add(new Official(id, lastName, firstName, gender, country,
            getOfficialLevelById(officialLevelId)));
      }
      return officials;
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving officials from database.", e);
    }
  }

  /**
   * Return an official with the given id
   * 
   * @param officialId
   *          Id of the official to return
   * @return Official with the given id
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public Official getOfficialById(Integer officialId) {
    String query = "SELECT * FROM official WHERE id = ?";
    List<Integer> params = new ArrayList<Integer>();
    params.add(officialId);

    try {
      ResultSet rs = executeQuery(query, params);

      if (rs.next()) {
        int id = rs.getInt("id");
        String lastName = rs.getString("last_name");
        String firstName = rs.getString("first_name");
        String gender = rs.getString("gender");
        String country = rs.getString("country");
        int officialLevelId = rs.getInt("official_level_id");
        return new Official(id, lastName, firstName, gender, country,
            getOfficialLevelById(officialLevelId));
      }
      return null;
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving officials from database.", e);
    }
  }

  /**
   * Returns a list of staff members for the given team.
   * 
   * @param teamId
   *          ID of the team, for which to retrieve staff members.
   * @return List of staff members.
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public <T extends Staff> List<T> getStaffByTeamId(Integer teamId,
      Class<T> clazz) {
    String query = "SELECT id, last_name as lastname, first_name as firstname, person_position as personposition FROM staff WHERE team_id = ?";

    try {
      return queryRunner.query(query, new BeanListHandler<T>(clazz), teamId);
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving staff members from database.", e);
    }
  }

  /**
   * Returns a staff member with the given id
   * 
   * @param staffId
   *          Id of the staff member to return
   * @return Staff member with the given id
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public Staff getStaffById(Integer staffId) {
    String query = "SELECT id, last_name as lastname, first_name as firstname, person_position as personposition FROM staff WHERE id = ?";
    try {
      return queryRunner.query(query, new BeanHandler<Staff>(Staff.class),
          staffId);
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving staff member from database.", e);
    }
  }

  /**
   * Returns a list of players for the given team.
   * 
   * @param <T>
   * 
   * @param teamId
   *          ID of the team, for which to retrieve players.
   * @return List of players.
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public <T extends Player> List<T> getPlayersByTeamId(Integer teamId,
      Class<T> clazz) {
    String query = "SELECT id, last_name as lastname, first_name as firstname FROM player WHERE team_id = ?";

    try {
      return queryRunner.query(query, new BeanListHandler<T>(clazz), teamId);
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving players from database.", e);
    }
  }

  /**
   * Returns id of the player based on team id and player number.
   * 
   * @param teamId
   *          Id of the team
   * @param playerNumber
   *          Number of the player
   * @return Id of the player if the player with given number exists in given
   *         team, {@code null} otherwise
   */
  public Integer getPlayerByTeamIdAndPlayerNumber(Integer teamId,
      Integer playerNumber) {
    String query = "SELECT id FROM tournament_player where tournament_team_id = ? AND player_number = ?";

    try {
      return queryRunner.query(query,
          new BeanHandler<TournamentPlayer>(TournamentPlayer.class), teamId,
          playerNumber).getId();
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving players from database.", e);
    }
  }

  /**
   * Returns the player with the given id
   * 
   * @param playerId
   *          Id of the player to return
   * @return Player with the given id
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public Player getPlayerById(Integer playerId) {
    String query = "SELECT id, last_name as lastname, first_name as firstname FROM player WHERE id = ?";

    try {
      return queryRunner.query(query, new BeanHandler<Player>(Player.class),
          playerId);
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving player from database.", e);
    }
  }

  /**
   * Returns team with the given team name from the given country.
   * 
   * @param teamName
   *          Name of the team to return.
   * @param country
   *          Country of the team.
   * @return Team with the given name from the given country
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public Team getTeamByNameAndCountry(String teamName, String country) {
    String query = "SELECT id, national_team as nationalteam, team_name as teamname, country, is_male as male FROM team WHERE team_name = ? AND country = ?";

    try {
      return queryRunner.query(query, new BeanHandler<Team>(Team.class),
          teamName, country);
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving team from database.", e);
    }
  }

  /**
   * Returns team with the given id
   * 
   * @param teamId
   *          Id of the team to return
   * @return Team with the given id
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public Team getTeamById(Integer teamId) {
    String query = "SELECT id, national_team as nationalteam, team_name as teamname, country, is_male as male FROM team WHERE id = ?";

    try {
      return queryRunner.query(query, new BeanHandler<Team>(Team.class),
          teamId);
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving team from database.", e);
    }
  }

  /**
   * Returns official level by id.
   * 
   * @param levelId
   *          Id of the official level to return.
   * @return Official level
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public OfficialLevel getOfficialLevelById(Integer levelId) {
    String query = "SELECT id, level_name as levelname, level_description as leveldescription FROM official_level WHERE id = ?";
    try {
      return queryRunner.query(query,
          new BeanHandler<OfficialLevel>(OfficialLevel.class), levelId);
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving officials from database.", e);
    }
  }

  /**
   * Returns official level by level name.
   * 
   * @param levelName
   *          Name of the level to return.
   * @return Official level
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public OfficialLevel getOfficialLevelByName(String levelName) {
    String query = "SELECT id, level_name as levelname, level_description as leveldescription FROM official_level WHERE level_name = ?";

    try {
      return queryRunner.query(query,
          new BeanHandler<OfficialLevel>(OfficialLevel.class), levelName);
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving officials from database.", e);
    }
  }

  /**
   * Returns tournament by id.
   * 
   * @param tournamentId
   *          Id of the tournament to return.
   * @return Tournament
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public Tournament getTournamentById(Integer tournamentId) {
    String query = "SELECT id, tournament_name as tournamentName, tournament_location as location, start_date as startDate, end_date as endDate FROM tournament WHERE id = ?";
    try {
      return queryRunner.query(query,
          new BeanHandler<Tournament>(Tournament.class), tournamentId);
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving tournament from database.", e);
    }
  }

  /**
   * Get teams that are participating at the given tournament
   * 
   * @param tournamentId
   *          Id of the tournament
   * @return List of teams participating at the given tournament
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public List<Team> getParticipatingTeams(Integer tournamentId) {
    String query = "SELECT t.id as id, t.national_team as nationalteam, t.team_name as teamname, t.country as country, t.is_male as male FROM team t, tournament_team tt WHERE tt.tournament_id = ? AND tt.team_id = t.id";
    try {
      return queryRunner.query(query, new BeanListHandler<Team>(Team.class),
          tournamentId);
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving tournament teams from database.", e);
    }
  }

  /**
   * Returns all venues where the tournament is taking place (as defined in
   * games themselves)
   * 
   * @param tournamentId
   *          Id of the tournament
   * @return List of all venues
   */
  public List<String> getTournamentVenues(Integer tournamentId) {
    String query = "SELECT DISTINCT venue from tournament_game WHERE tournament_id = ?";
    List<Integer> params = new ArrayList<Integer>();
    params.add(tournamentId);

    try {
      ResultSet rs = executeQuery(query, params);
      List<String> tournamentVenues = new ArrayList<String>();
      while (rs.next()) {
        String venue = rs.getString("venue");
        tournamentVenues.add(venue);
      }

      return tournamentVenues;
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving tournament teams from database.", e);
    }
  }

  /**
   * Returns all tournament teams that are participating at the given
   * tournament.
   * 
   * @param tournamentId
   *          Id of the tournament
   * @return List of tournament teams teams participating at the given
   *         tournament
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public List<TournamentTeam> getTournamentTeams(Integer tournamentId) {
    String query = "SELECT tt.id as id, t.national_team as nationalteam, t.team_name as teamname, t.country as country, t.is_male as male FROM team t, tournament_team tt WHERE tt.tournament_id = ? AND tt.team_id = t.id";
    try {
      return queryRunner.query(query,
          new BeanListHandler<TournamentTeam>(TournamentTeam.class),
          tournamentId);
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving tournament teams from database.", e);
    }
  }

  /**
   * Returns id of tournament_team for the given team at the given tournament
   * 
   * @param tournamentId
   *          Id of the tournament
   * @param teamId
   *          Id of the team
   * @return Id of tournament_team
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public Integer getTournamentTeamId(Integer tournamentId, Integer teamId) {
    String query = "SELECT tt.id as id FROM team t, tournament_team tt WHERE tt.tournament_id = ? AND t.id = ? AND tt.team_id = t.id";
    try {
      return queryRunner
          .query(query, new BeanHandler<Team>(Team.class), tournamentId, teamId)
          .getId();
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving tournament team from database.", e);
    }
  }

  /**
   * Returns tournamentTeam by id
   * 
   * @param tournamentTeamId
   *          ID of tournamentTeam to return
   * @return TournamentTeam with the given id
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public TournamentTeam getTournamentTeamById(Integer tournamentTeamId) {
    String query = "SELECT tt.id, t.national_team as nationalteam, t.team_name as teamname, t.country, t.is_male as male FROM team t, tournament_team tt WHERE t.id = tt.team_id AND tt.id = ?";
    try {
      return queryRunner.query(query,
          new BeanHandler<TournamentTeam>(TournamentTeam.class),
          tournamentTeamId);
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving tournament team from database.", e);
    }
  }

  /**
   * Returns list of players representing the given team
   * 
   * @param tournamentTeamId
   *          ID of tournament team for which to retrieve players
   * @return List of players of the given tournament team
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public List<TournamentPlayer> getTournamentTeamPlayers(
      Integer tournamentTeamId) {
    String query = "SELECT tp.id, tp.player_number as playernumber, p.last_name as lastname, p.first_name as firstname"
        + " FROM tournament_player tp, player p WHERE tp.player_id = p.id AND tp.tournament_team_id = ?";
    try {
      return queryRunner.query(query,
          new BeanListHandler<TournamentPlayer>(TournamentPlayer.class),
          tournamentTeamId);
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving tournament players from database.", e);
    }
  }

  /**
   * Returns tournament player
   * 
   * @param playerId
   *          Id of player to return
   * @return Player
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public TournamentPlayer getTournamentPlayer(Integer playerId) {
    String query = "SELECT tp.id, tp.player_number as playernumber, p.last_name as lastname, p.first_name as firstname, t.is_male as male, "
        + " t.team_name as teamName"
        + " FROM tournament_player tp, player p, team t WHERE tp.player_id = p.id AND p.team_id = t.id AND tp.id = ?";
    try {
      return queryRunner.query(query,
          new BeanHandler<>(TournamentPlayer.class), playerId);
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving tournament player from database.", e);
    }
  }

  /**
   * Returns numbers of players representing the given team
   * 
   * @param tournamentTeamId
   *          ID of tournament team for which to retrieve player numbers
   * @return List of player numbers of the given tournament team
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public List<Integer> getTournamentTeamPlayerNumbers(
      Integer tournamentTeamId) {
    String query = "SELECT tp.player_number"
        + " FROM tournament_player tp WHERE tp.tournament_team_id = ?";
    try {
      return queryRunner.query(query, new IntegerListHandler(),
          tournamentTeamId);
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving tournament players from database.", e);
    }
  }

  /**
   * Returns list of staff members representing the given team
   * 
   * @param tournamentTeamId
   *          ID of tournament team for which to retrieve staff members
   * @return List of staff members of the given tournament team
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public List<TournamentStaff> getTournamentTeamStaff(
      Integer tournamentTeamId) {
    String query = "SELECT ts.id, s.last_name as lastname, s.first_name as firstname, s.person_position as personposition FROM tournament_staff ts, staff s WHERE ts.staff_id = s.id AND ts.tournament_team_id = ?";
    try {
      return queryRunner.query(query,
          new BeanListHandler<TournamentStaff>(TournamentStaff.class),
          tournamentTeamId);
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving tournament staff from database.", e);
    }
  }

  /**
   * Returns TournamentOfficial by id
   * 
   * @param tournamentOfficialId
   *          ID of TournamentOfficial to return
   * @return {@link TournamentOfficial} with the given id
   * @throws InternalTechnicalException
   *           If problem with database occurs
   */
  public TournamentOfficial getTournamentOfficialById(
      Integer tournamentOfficialId) {
    String query = "SELECT official_id from tournament_official WHERE id = ?";
    List<Integer> params = new ArrayList<Integer>();
    params.add(tournamentOfficialId);
    try {
      ResultSet rs = executeQuery(query, params);
      if (rs.next()) {
        Integer officialId = rs.getInt("official_id");
        Official official = getOfficialById(officialId);
        if (official != null) {
          return new TournamentOfficial(tournamentOfficialId,
              official.getLastName(), official.getFirstName(),
              official.getGender(), official.getCountry(),
              official.getOfficialLevel());
        }
      }
      return null;
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving tournament official from database.", e);
    }
  }

  /**
   * Returns all officials that are participating at the given tournament.
   * 
   * @param tournamentId
   *          Id of the tournament
   * @return List of officials participating at the given tournament * @throws
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public List<Official> getParticipatingOfficials(Integer tournamentId) {
    String query = "SELECT o.id, o.last_name, o.first_name, o.gender, o.country, o.official_level_id FROM official o, tournament_official tto WHERE tto.tournament_id = ? AND tto.official_id = o.id";
    List<Integer> params = new ArrayList<Integer>();
    params.add(tournamentId);

    try {
      ResultSet rs = executeQuery(query, params);
      List<Official> officials = new ArrayList<Official>();

      while (rs.next()) {
        int id = rs.getInt("id");
        String lastName = rs.getString("last_name");
        String firstName = rs.getString("first_name");
        String gender = rs.getString("gender");
        String country = rs.getString("country");
        int officialLevelId = rs.getInt("official_level_id");
        officials.add(new Official(id, lastName, firstName, gender, country,
            getOfficialLevelById(officialLevelId)));
        // officials.add(instance);
      }
      return officials;
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving officials from database.", e);
    }
  }

  /**
   * Returns all tournament officials that are participating at the given
   * tournament.
   * 
   * @param tournamentId
   *          Id of the tournament
   * @return List of tournament officials participating at the given tournament
   *         * @throws
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public List<TournamentOfficial> getTournamentOfficials(Integer tournamentId) {
    String query = "SELECT tto.id, o.last_name, o.first_name, o.gender, o.country, o.official_level_id FROM official o, tournament_official tto WHERE tto.tournament_id = ? AND tto.official_id = o.id";
    List<Integer> params = new ArrayList<Integer>();
    params.add(tournamentId);

    try {
      ResultSet rs = executeQuery(query, params);
      List<TournamentOfficial> officials = new ArrayList<TournamentOfficial>();

      while (rs.next()) {
        int id = rs.getInt("id");
        String lastName = rs.getString("last_name");
        String firstName = rs.getString("first_name");
        String gender = rs.getString("gender");
        String country = rs.getString("country");
        int officialLevelId = rs.getInt("official_level_id");
        // T instance = clazz.newInstance();
        // instance.setId(id);
        // instance.setLastName(lastName);
        // instance.setFirstName(firstName);
        // instance.setGender(gender);
        // instance.setCountry(country);
        // instance.setOfficialLevel(getOfficialLevelById(officialLevelId));
        officials.add(new TournamentOfficial(id, lastName, firstName, gender,
            country, getOfficialLevelById(officialLevelId)));
        // officials.add(instance);
      }
      return officials;
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving officials from database.", e);
    }
  }

  /**
   * Returns games at the given tournament within given range
   * 
   * @param tournamentId
   *          ID of the tournament
   * @param fromGame
   *          First game of range to return
   * @param toGame
   *          Last game of range to return
   * @return List of games at the given tournament
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public List<TournamentGame> getTournamentGames(Integer tournamentId,
      int fromGame, int toGame) {
    return getTournamentGamesByVenue(tournamentId, null, fromGame, toGame);
  }

  /**
   * Returns all games at the given tournament
   * 
   * @param tournamentId
   *          ID of the tournament
   * @return List of games at the given tournament
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public List<TournamentGame> getTournamentGames(Integer tournamentId) {
    return getTournamentGamesByVenue(tournamentId, null, null, null);
  }

  /**
   * Returns all games at the given tournament that take place at the given
   * venue
   * 
   * @param tournamentId
   *          ID of the tournament
   * @param venue
   *          Venue for which the games should be returned
   * @return List of games at the given tournament
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public List<TournamentGame> getTournamentGamesByVenue(Integer tournamentId,
      String venue, Integer fromGame, Integer toGame) {
    StringBuilder queryBuilder = new StringBuilder();
    queryBuilder
        .append("SELECT * from tournament_game WHERE tournament_id = ?");
    if (venue != null) {
      queryBuilder.append(" AND venue = ?");
    }
    if (fromGame != null) {
      queryBuilder.append(" AND game_no >= ?");
    }
    if (toGame != null) {
      queryBuilder.append(" AND game_no <= ?");
    }
    List<Object> params = new ArrayList<Object>();
    params.add(tournamentId);
    if (venue != null) {
      params.add(venue);
    }
    if (fromGame != null) {
      params.add(fromGame);
    }
    if (toGame != null) {
      params.add(toGame);
    }

    try {
      ResultSet rs = executeQuery(queryBuilder.toString(), params);
      List<TournamentGame> tournamentGames = new ArrayList<TournamentGame>();
      while (rs.next()) {
        tournamentGames.add(buildTournamentGame(rs));
      }

      return tournamentGames;
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving tournament games from database.", e);
    }
  }

  /**
   * Returns a tournament game with the given id
   * 
   * @param tournamentGameId
   *          ID of the tournament game
   * @return TournamentGame
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public TournamentGame getTournamentGame(Integer tournamentGameId) {
    String query = "SELECT * from tournament_game WHERE id = ?";
    List<Integer> params = new ArrayList<Integer>();
    params.add(tournamentGameId);

    try {
      ResultSet rs = executeQuery(query, params);

      if (rs.next()) {
        return buildTournamentGame(rs);
      }
      return null;
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving tournament games from database.", e);
    }
  }

  public Optional<TournamentGame> getTournamentGame(Integer gameNumber,
      String gameTime, TournamentTeam teamA, TournamentTeam teaamB) {
    String query = "SELECT * from tournament_game WHERE game_no = ? and game_time = ? "
        + "and team_a_id = ? and team_b_id = ?";
    List<String> params = new ArrayList<>();
    params.add(gameNumber.toString());
    params.add(gameTime);
    params.add(teamA.getId().toString());
    params.add(teaamB.getId().toString());

    try {
      ResultSet rs = executeQuery(query, params);

      if (rs.next()) {
        return Optional.of(buildTournamentGame(rs));
      }
      return Optional.empty();
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Error while retrieving tournament games from database.", e);
    }
  }

  private TournamentGame buildTournamentGame(ResultSet rs) throws SQLException {
    Integer id = rs.getInt("id");
    Integer tournamentId = rs.getInt("tournament_id");
    Integer gameNumber = rs.getInt("game_no");
    Date gameDate = rs.getDate("game_date");
    String gameTime = rs.getString("game_time");
    String pool = rs.getString("pool");
    String venue = rs.getString("venue");
    String gender = rs.getString("gender");
    boolean needsWinner = rs.getBoolean("needs_winner");
    Integer tournamentTeamAId = rs.getInt("team_a_id");
    TournamentTeam tournamentTeamA = getTournamentTeamById(tournamentTeamAId);
    Integer tournamentTeamBId = rs.getInt("team_b_id");
    TournamentTeam tournamentTeamB = getTournamentTeamById(tournamentTeamBId);
    Integer referee1Id = rs.getInt("referee_1_id");
    TournamentOfficial referee1 = getTournamentOfficialById(referee1Id);
    Integer referee2Id = rs.getInt("referee_2_id");
    TournamentOfficial referee2 = getTournamentOfficialById(referee2Id);
    Integer tenSec1Id = rs.getInt("ten_sec_1_id");
    TournamentOfficial tenSeconds1 = getTournamentOfficialById(tenSec1Id);
    Integer tenSec2Id = rs.getInt("ten_sec_2_id");
    TournamentOfficial tenSeconds2 = getTournamentOfficialById(tenSec2Id);
    Integer scoredId = rs.getInt("scorer_id");
    TournamentOfficial scorer = getTournamentOfficialById(scoredId);
    Integer timerId = rs.getInt("timer_id");
    TournamentOfficial timer = getTournamentOfficialById(timerId);
    Integer backupTimerId = rs.getInt("backup_timer_id");
    TournamentOfficial backupTimer = getTournamentOfficialById(backupTimerId);
    Integer goalJudge1Id = rs.getInt("goal_judge_1_id");
    TournamentOfficial goalJudge1 = getTournamentOfficialById(goalJudge1Id);
    Integer goalJudge2Id = rs.getInt("goal_judge_2_id");
    TournamentOfficial goalJudge2 = getTournamentOfficialById(goalJudge2Id);
    Integer goalJudge3Id = rs.getInt("goal_judge_3_id");
    TournamentOfficial goalJudge3 = getTournamentOfficialById(goalJudge3Id);
    Integer goalJudge4Id = rs.getInt("goal_judge_4_id");
    TournamentOfficial goalJudge4 = getTournamentOfficialById(goalJudge4Id);
    Integer scoreTeamA = null;
    if (rs.getObject("score_team_a") != null) {
      scoreTeamA = rs.getInt("score_team_a");
    }
    Integer scoreTeamB = null;
    if (rs.getObject("score_team_b") != null) {
      scoreTeamB = rs.getInt("score_team_b");
    }

    return new TournamentGame(id, getTournamentById(tournamentId), gameNumber,
        gameDate, gameTime, pool, venue, gender, needsWinner, tournamentTeamA,
        tournamentTeamB, referee1, referee2, tenSeconds1, tenSeconds2, scorer,
        timer, backupTimer, goalJudge1, goalJudge2, goalJudge3, goalJudge4,
        scoreTeamA, scoreTeamB);
  }

  public Map<TournamentOfficial, List<RefereeGame>> getRefereeGames(
      int tournamentId, int fromGame, int toGame) {
    List<TournamentGame> tournamentGames = getTournamentGames(tournamentId,
        fromGame, toGame);
    Map<TournamentOfficial, List<RefereeGame>> stats = new HashMap<>();
    for (TournamentGame game : tournamentGames) {
      handleRefGames(stats, game, game.getReferee1(), "Referee TS");
      handleRefGames(stats, game, game.getReferee2(), "Referee FS");
      handleRefGames(stats, game, game.getTenSeconds1(), "Ten seconds");
      handleRefGames(stats, game, game.getTenSeconds2(), "Ten seconds");
      handleRefGames(stats, game, game.getScorer(), "Scorer");
      handleRefGames(stats, game, game.getTimer(), "Timer");
      handleRefGames(stats, game, game.getBackupTimer(), "Backup Timer");
      handleRefGames(stats, game, game.getGoalJudge1(), "Goal judge");
      handleRefGames(stats, game, game.getGoalJudge2(), "Goal judge");
      handleRefGames(stats, game, game.getGoalJudge3(), "Goal judge");
      handleRefGames(stats, game, game.getGoalJudge4(), "Goal judge");
    }

    return stats;
  }

  private void handleRefGames(Map<TournamentOfficial, List<RefereeGame>> stats,
      TournamentGame game, TournamentOfficial official, String position) {
    if (official == null) {
      return;
    }
    List<RefereeGame> games = stats.get(official);
    if (games == null) {
      games = new ArrayList<>();
      stats.put(official, games);
    }
    games.add(new RefereeGame(game.getGameNumber(), game.getGameDate(),
        game.getGameTime(), game.getVenue(), position));
  }

  public List<RefereeStats> getTournamentRefStats(int tournamentId) {
    List<TournamentGame> tournamentGames = getTournamentGames(tournamentId);
    List<RefereeStats> statsList = new ArrayList<RefereeStats>();
    for (TournamentGame game : tournamentGames) {
      // REFEREES
      handleStats(statsList, game.getReferee1(), TournamentStatsType.REFEREE,
          game.getGameDate());
      handleStats(statsList, game.getReferee2(), TournamentStatsType.REFEREE,
          game.getGameDate());

      // TABLE OFFICIALS
      handleStats(statsList, game.getTenSeconds1(),
          TournamentStatsType.TABLE_OFFICIAL, game.getGameDate());
      handleStats(statsList, game.getTenSeconds2(),
          TournamentStatsType.TABLE_OFFICIAL, game.getGameDate());
      handleStats(statsList, game.getTimer(),
          TournamentStatsType.TABLE_OFFICIAL, game.getGameDate());
      handleStats(statsList, game.getBackupTimer(),
          TournamentStatsType.TABLE_OFFICIAL, game.getGameDate());
      handleStats(statsList, game.getScorer(),
          TournamentStatsType.TABLE_OFFICIAL, game.getGameDate());

      // GOAL JUDGES
      handleStats(statsList, game.getGoalJudge1(),
          TournamentStatsType.GOAL_JUDGE, game.getGameDate());
      handleStats(statsList, game.getGoalJudge2(),
          TournamentStatsType.GOAL_JUDGE, game.getGameDate());
      handleStats(statsList, game.getGoalJudge3(),
          TournamentStatsType.GOAL_JUDGE, game.getGameDate());
      handleStats(statsList, game.getGoalJudge4(),
          TournamentStatsType.GOAL_JUDGE, game.getGameDate());
    }

    return statsList;
  }

  private void handleStats(List<RefereeStats> statsList,
      TournamentOfficial official, TournamentStatsType type, Date gameDate) {
    if (official == null) {
      return;
    }

    RefereeStats stats = new RefereeStats(official);
    if (statsList.contains(stats)) {
      stats = statsList.get(statsList.indexOf(stats));
    } else {
      statsList.add(stats);
    }
    switch (type) {
    case REFEREE:
      stats.increaseGamesAsReferee();
      break;
    case TABLE_OFFICIAL:
      stats.increaseGamesAsTableOfficial();
      break;
    case GOAL_JUDGE:
      stats.increaseGamesAsGoalJudge();
      break;
    }
  }

  public Map<TournamentPlayer, Integer> getTournamentScorers(
      Integer tournamentId) {
    String query = "SELECT s.id, s.tournament_player_id as playerId, s.no_of_goals as noOfGoals "
        + "FROM tournament_game g, game_score s "
        + "WHERE s.game_id = g.id AND g.tournament_id = ?";
    try {
      List<GameScore> gameScorers = queryRunner.query(query,
          new BeanListHandler<GameScore>(GameScore.class), tournamentId);
      Map<Integer, Integer> scorers = new HashMap<Integer, Integer>();
      for (GameScore gameScorer : gameScorers) {
        int playerId = gameScorer.getPlayerId();
        if (scorers.containsKey(playerId)) {
          Integer playerGoals = scorers.get(playerId);
          scorers.put(playerId, playerGoals + gameScorer.getNoOfGoals());
        } else {
          scorers.put(playerId, gameScorer.getNoOfGoals());
        }
      }

      Map<TournamentPlayer, Integer> tournamentScorers = new HashMap<TournamentPlayer, Integer>();
      for (Integer playerId : scorers.keySet()) {
        TournamentPlayer player = getTournamentPlayer(playerId);
        tournamentScorers.put(player, scorers.get(playerId));
      }
      return tournamentScorers;
    } catch (SQLException e) {
      throw new InternalTechnicalException("Problem getting game scorers.", e);
    }
  }

  /**
   * Inserts a new official to the database.
   * 
   * @param official
   *          Official to be inserted.
   * @return Id of the inserted official.
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public int insertOfficial(Official official) {
    String query = "INSERT INTO official(last_name, first_name, gender, country, official_level_id, admin_data) values (?, ?, ?, ?, ?, ?)";

    try {
      queryRunner.update(query, official.getLastName(), official.getFirstName(),
          official.getGender(), official.getCountry(),
          official.getOfficialLevel().getId(), official.isAdminData());
      return getMaxId("official");
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Problem inserting official to database.", e);
    }
  }

  /**
   * Inserts a new staff member to the database.
   * 
   * @param staffMember
   *          Staff member to be inserted.
   * @param Id
   *          of the team to which staff member belongs
   * @return Id of the inserted staff member.
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public int insertStaffMember(Staff staffMember, Integer teamId) {
    String query = "INSERT INTO staff(last_name, first_name, person_position, team_id, admin_data) VALUES (?, ?, ?, ?, ?)";

    try {
      queryRunner.update(query, staffMember.getLastName(),
          staffMember.getFirstName(), staffMember.getPersonPosition(), teamId,
          staffMember.isAdminData());
      return getMaxId("staff");
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Problem inserting staff member to database.", e);
    }
  }

  /**
   * Inserts a new player to the database.
   * 
   * @param player
   *          Player to be inserted.
   * @param teamId
   *          Id of the team to which a player belong
   * @return Id of the inserted player.
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public int insertPlayer(Player player, Integer teamId) {
    String query = "INSERT INTO player(last_name, first_name, team_id, admin_data) VALUES (?, ?, ?, ?)";

    try {
      queryRunner.update(query, player.getLastName(), player.getFirstName(),
          teamId, player.isAdminData());
      return getMaxId("player");
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Problem inserting player to database.", e);
    }
  }

  /**
   * Inserts a new team to the database.
   * 
   * @param team
   *          Team to be inserted.
   * @return Id of the inserted team.
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public int insertTeam(Team team) {
    String query = "INSERT INTO team(team_name, country, national_team, admin_data, is_male) values (?, ?, ?, ?, ?)";

    try {
      queryRunner.update(query, team.getTeamName(), team.getCountry(),
          team.isNationalTeam(), team.isAdminData(), team.isMale());
      return getMaxId("team");
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Problem inserting team to database.", e);
    }
  }

  /**
   * Inserts a new tournament to the database
   * 
   * @param tournament
   *          Tournament to be inserted
   * @return Id of the inserted tournament
   * @throws InternalTechnicalException
   *           If problem with database occurs
   */
  public int insertTournament(Tournament tournament) {
    String query = "INSERT INTO tournament(tournament_name, tournament_location, start_date, end_date) values (?, ?, ?, ?)";

    try {
      queryRunner.update(query, tournament.getTournamentName(),
          tournament.getLocation(), tournament.getStartDate(),
          tournament.getEndDate());
      return getMaxId("tournament");
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Problem inserting tournament to database.", e);
    }
  }

  /**
   * Inserts a new tournament game to the database
   * 
   * @param tournamentGame
   *          Tournament game to be inserted
   * @return Id of the inserted tournament game
   * @throws InternalTechnicalException
   *           If problem with database occurs
   */
  public int insertTournamentGame(TournamentGame tournamentGame) {
    String query = "INSERT INTO tournament_game (tournament_id, game_no, game_date, game_time, pool, venue, gender, needs_winner, team_a_id, "
        + "team_b_id, referee_1_id, referee_2_id, ten_sec_1_id, ten_sec_2_id, scorer_id, shot_recorder_id, timer_id, backup_timer_id, "
        + "goal_judge_1_id, goal_judge_2_id, goal_judge_3_id, goal_judge_4_id) values(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
    Integer tournamentId = tournamentGame.getTournament().getId();
    Integer gameNo = tournamentGame.getGameNumber();
    Date gameDate = tournamentGame.getGameDate();
    String gameTime = tournamentGame.getGameTime();
    String pool = tournamentGame.getPool();
    String venue = tournamentGame.getVenue();
    String gender = tournamentGame.getGender();
    boolean needsWinner = tournamentGame.getNeedsWinner();
    Integer teamAId = tournamentGame.getTeamA().getId();
    Integer teamBId = tournamentGame.getTeamB().getId();
    Integer referee1Id = tournamentGame.getReferee1().getId();
    Integer referee2Id = tournamentGame.getReferee2().getId();
    Integer tenSec1Id = tournamentGame.getTenSeconds1() == null ? null
        : tournamentGame.getTenSeconds1().getId();
    Integer tenSec2Id = tournamentGame.getTenSeconds2() == null ? null
        : tournamentGame.getTenSeconds2().getId();
    Integer scorerId = tournamentGame.getScorer() == null ? null
        : tournamentGame.getScorer().getId();
    Integer shotRecorderId = null;
    Integer timerId = tournamentGame.getTimer() == null ? null
        : tournamentGame.getTimer().getId();
    Integer backupTimerId = tournamentGame.getBackupTimer() == null ? null
        : tournamentGame.getBackupTimer().getId();
    Integer goalJudge1Id = tournamentGame.getGoalJudge1() == null ? null
        : tournamentGame.getGoalJudge1().getId();
    Integer goalJudge2Id = tournamentGame.getGoalJudge2() == null ? null
        : tournamentGame.getGoalJudge2().getId();
    Integer goalJudge3Id = tournamentGame.getGoalJudge3() == null ? null
        : tournamentGame.getGoalJudge3().getId();
    Integer goalJudge4Id = tournamentGame.getGoalJudge4() == null ? null
        : tournamentGame.getGoalJudge4().getId();
    try {
      queryRunner.update(query, tournamentId, gameNo, gameDate, gameTime, pool,
          venue, gender, needsWinner, teamAId, teamBId, referee1Id, referee2Id,
          tenSec1Id, tenSec2Id, scorerId, shotRecorderId, timerId,
          backupTimerId, goalJudge1Id, goalJudge2Id, goalJudge3Id,
          goalJudge4Id);
      return getMaxId("tournament_game");
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Problem inserting tournament_game to database.", e);
    }
  }

  /**
   * Adds team to tournament
   * 
   * @param tournamentId
   *          Tournament id
   * @param teamId
   *          Team id
   * @return Id of the inserted tournament_team
   * @throws InternalTechnicalException
   *           If problem with database occurs
   */
  public int addTeamToTournament(Integer tournamentId, Integer teamId) {
    String query = "INSERT INTO tournament_team(tournament_id, team_id) values (?, ?)";
    try {
      queryRunner.update(query, tournamentId, teamId);
      return getMaxId("tournament_team");
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Problem inserting tournament_team to database.", e);
    }
  }

  /**
   * Adds official to tournament
   * 
   * @param tournamentId
   *          Tournament id
   * @param officialId
   *          Official id
   * @throws InternalTechnicalException
   *           If problem with database occurs
   */
  public void addOfficialToTournament(Integer tournamentId,
      Integer officialId) {
    String query = "INSERT INTO tournament_official(tournament_id, official_id) values (?, ?)";
    try {
      queryRunner.update(query, tournamentId, officialId);
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Problem inserting tournament_official to database.", e);
    }
  }

  /**
   * Adds player to the tournament
   * 
   * @param playerId
   *          Id of the player to add
   * @param tournamentTeamId
   *          Id of the tournament
   * @param playerNumber
   *          Player's number at the given tournament
   * @throws InternalTechnicalException
   *           If problem with database occurs
   */
  public void insertTournamentPlayer(Integer playerId, Integer tournamentTeamId,
      Integer playerNumber) {
    String query = "INSERT INTO tournament_player(player_id, tournament_team_id, player_number) values (?, ?, ?)";
    try {
      queryRunner.update(query, playerId, tournamentTeamId, playerNumber);
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Problem inserting tournament_player to database.", e);
    }
  }

  /**
   * Adds staff to the tournament
   * 
   * @param staffId
   *          Id of the staff to add
   * @param tournamentTeamId
   *          Id of the tournament
   * @throws InternalTechnicalException
   *           If problem with database occurs
   */
  public void insertTournamentStaff(Integer staffId, Integer tournamentTeamId) {
    String query = "INSERT INTO tournament_staff(staff_id, tournament_team_id) values (?, ?)";
    try {
      queryRunner.update(query, staffId, tournamentTeamId);
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Problem inserting tournament_staff to database.", e);
    }
  }

  /**
   * Updates the official in the database.
   * 
   * @param official
   *          Official to be updated.
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public void updateOfficial(Official official) {
    String query = "UPDATE official SET last_name = ?, first_name = ?, gender = ?, country=?, official_level_id = ?, admin_data = ? WHERE id = ?";

    try {
      queryRunner.update(query, official.getLastName(), official.getFirstName(),
          official.getGender(), official.getCountry(),
          official.getOfficialLevel().getId(), official.isAdminData(),
          official.getId());
    } catch (SQLException e) {
      throw new InternalTechnicalException("Problem updating official", e);
    }
  }

  /**
   * Updates a tournament game in the database
   * 
   * @param tournamentGame
   *          Tournament game to be updated
   * @throws InternalTechnicalException
   *           If problem with database occurs
   */
  public void updateTournamentGame(TournamentGame tournamentGame) {
    String query = "UPDATE tournament_game SET tournament_id = ?, game_no = ?, game_date = ?, game_time = ?, pool = ?, venue = ?, gender = ?, needs_winner = ?, team_a_id = ?, "
        + "team_b_id = ?, referee_1_id = ?, referee_2_id = ?, ten_sec_1_id = ?, ten_sec_2_id = ?, scorer_id = ?, shot_recorder_id = ?, timer_id = ?, backup_timer_id = ?, "
        + "goal_judge_1_id = ?, goal_judge_2_id = ?, goal_judge_3_id = ?, goal_judge_4_id = ? WHERE id = ?";
    Integer tournamentId = tournamentGame.getTournament().getId();
    Integer gameNo = tournamentGame.getGameNumber();
    Date gameDate = tournamentGame.getGameDate();
    String gameTime = tournamentGame.getGameTime();
    String pool = tournamentGame.getPool();
    String venue = tournamentGame.getVenue();
    String gender = tournamentGame.getGender();
    boolean needsWinner = tournamentGame.getNeedsWinner();
    Integer teamAId = tournamentGame.getTeamA().getId();
    Integer teamBId = tournamentGame.getTeamB().getId();
    Integer referee1Id = tournamentGame.getReferee1().getId();
    Integer referee2Id = tournamentGame.getReferee2().getId();
    Integer tenSec1Id = tournamentGame.getTenSeconds1() == null ? null
        : tournamentGame.getTenSeconds1().getId();
    Integer tenSec2Id = tournamentGame.getTenSeconds2() == null ? null
        : tournamentGame.getTenSeconds2().getId();
    Integer scorerId = tournamentGame.getScorer() == null ? null
        : tournamentGame.getScorer().getId();
    Integer shotRecorderId = null;
    Integer timerId = tournamentGame.getTimer() == null ? null
        : tournamentGame.getTimer().getId();
    Integer backupTimerId = tournamentGame.getBackupTimer() == null ? null
        : tournamentGame.getBackupTimer().getId();
    Integer goalJudge1Id = tournamentGame.getGoalJudge1() == null ? null
        : tournamentGame.getGoalJudge1().getId();
    Integer goalJudge2Id = tournamentGame.getGoalJudge2() == null ? null
        : tournamentGame.getGoalJudge2().getId();
    Integer goalJudge3Id = tournamentGame.getGoalJudge3() == null ? null
        : tournamentGame.getGoalJudge3().getId();
    Integer goalJudge4Id = tournamentGame.getGoalJudge4() == null ? null
        : tournamentGame.getGoalJudge4().getId();
    try {
      queryRunner.update(query, tournamentId, gameNo, gameDate, gameTime, pool,
          venue, gender, needsWinner, teamAId, teamBId, referee1Id, referee2Id,
          tenSec1Id, tenSec2Id, scorerId, shotRecorderId, timerId,
          backupTimerId, goalJudge1Id, goalJudge2Id, goalJudge3Id, goalJudge4Id,
          tournamentGame.getId());
    } catch (SQLException e) {
      throw new InternalTechnicalException("Problem updating tournament_game",
          e);
    }
  }

  /**
   * Updates the staff member in the database.
   * 
   * @param staffMember
   *          Staff member to be updated.
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public void updateStaffMember(Staff staffMember) {
    String query = "UPDATE staff SET last_name = ?, first_name = ?, person_position = ?, admin_data = ? WHERE id = ?";

    try {
      queryRunner.update(query, staffMember.getLastName(),
          staffMember.getFirstName(), staffMember.getPersonPosition(),
          staffMember.isAdminData(), staffMember.getId());

      query = "SELECT team_id FROM staff WHERE id = ?";
      List<Object> params = new ArrayList<Object>();
      params.clear();
      params.add(staffMember.getId());
      ResultSet rs = executeQuery(query, params);
      if (rs.next()) {
        int teamId = rs.getInt("team_id");
        query = "UPDATE team SET admin_data = ? WHERE id = ?";
        queryRunner.update(query, false, teamId);
      }

    } catch (SQLException e) {
      throw new InternalTechnicalException("Problem updating staff member", e);
    }
  }

  /**
   * Updates the player in the database.
   * 
   * @param player
   *          Player to be updated.
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public void updatePlayer(Player player) {
    String query = "UPDATE player SET last_name = ?, first_name = ?, admin_data = ? WHERE id = ?";

    try {
      queryRunner.update(query, player.getLastName(), player.getFirstName(),
          player.isAdminData(), player.getId());

      query = "SELECT team_id FROM player WHERE id = ?";
      List<Object> params = new ArrayList<Object>();
      params.clear();
      params.add(player.getId());

      ResultSet rs = executeQuery(query, params);
      if (rs.next()) {

        int teamId = rs.getInt("team_id");
        query = "UPDATE team SET admin_data = ? WHERE id = ?";
        queryRunner.update(query, false, teamId);
      }
    } catch (SQLException e) {
      throw new InternalTechnicalException("Problem updating player", e);
    }
  }

  /**
   * Updates the tournament in the database
   * 
   * @param tournament
   *          Tournament to be updated
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public void updateTournament(Tournament tournament) {
    String query = "UPDATE tournament SET tournament_name = ?, tournament_location = ?, start_date = ?, end_date = ? WHERE id = ?";

    try {
      queryRunner.update(query, tournament.getTournamentName(),
          tournament.getLocation(), tournament.getStartDate(),
          tournament.getEndDate(), tournament.getId());
    } catch (SQLException e) {
      throw new InternalTechnicalException("Problem updating tournament", e);
    }
  }

  /**
   * Updates the tournament player in database
   * 
   * @param player
   *          Player to be updated
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public void updateTournamentPlayer(TournamentPlayer player) {
    String query = "UPDATE tournament_player SET player_number = ? WHERE id = ?";
    try {
      queryRunner.update(query, player.getPlayerNumber(), player.getId());
    } catch (SQLException e) {
      throw new InternalTechnicalException("Problem updating tournament player",
          e);
    }
  }

  /**
   * Sets the game score for the given game
   * 
   * @param gameId
   *          Id of the game
   * @param scoreTeamA
   *          Score of team A
   * @param scoreTeamB
   *          Score of team B
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public void setGameScore(Integer gameId, Integer scoreTeamA,
      Integer scoreTeamB) {
    String query = "UPDATE tournament_game SET score_team_a = ?, score_team_b = ? WHERE id = ?";

    try {
      queryRunner.update(query, scoreTeamA, scoreTeamB, gameId);
    } catch (SQLException e) {
      throw new InternalTechnicalException("Problem setting game score", e);
    }
  }

  /**
   * Sets the game scorers for each team for the given game
   * 
   * @param gameId
   *          Id of the game
   * @param scorersTeamA
   *          Map of scorers (playerNumber, noOfGoals) for team A
   * @param scorersTeamB
   *          Map of scorers (playerNumber, noOfGoals) for team B
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public void setGameScorers(Integer gameId, Integer teamAId, Integer teamBId,
      Map<Integer, Integer> scorersTeamA, Map<Integer, Integer> scorersTeamB) {
    String query = "INSERT INTO game_score (game_id, tournament_player_id, no_of_goals) values (?, ?, ?)";
    String deleteQuery = "DELETE FROM game_score WHERE game_id = ?";
    try {
      queryRunner.update(deleteQuery, gameId);
      for (Integer playerNo : scorersTeamA.keySet()) {
        Integer playerId = getPlayerByTeamIdAndPlayerNumber(teamAId, playerNo);
        queryRunner.update(query, gameId, playerId, scorersTeamA.get(playerNo));
      }
      for (Integer playerNo : scorersTeamB.keySet()) {
        Integer playerId = getPlayerByTeamIdAndPlayerNumber(teamBId, playerNo);
        queryRunner.update(query, gameId, playerId, scorersTeamB.get(playerNo));
      }
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Problem inserting game scorers to database.", e);
    }
  }

  /**
   * Deletes the given official from database.
   * 
   * @param officialId
   *          Id of the official to delete.
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   * @throws InternalIntegrityConstraintException
   *           If official is referenced from another entity
   *           (tournament_official) and can not be deleted
   */
  public void deleteOfficialById(Integer officialId) {
    String query = "DELETE FROM official WHERE id = ?";
    try {
      queryRunner.update(query, officialId);
    } catch (SQLException e) {
      if (e.getMessage() != null
          && e.getMessage().startsWith("Integrity constraint violation")) {
        throw new InternalIntegrityConstraintException(
            "Official is participating at one of the tournaments and can not be deleted",
            e);
      }
      throw new InternalTechnicalException("Problem deleting official", e);
    }
  }

  /**
   * Deletes the given staff member from database.
   * 
   * @param staffId
   *          Id of the staff member to delete.
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public void deleteStaffMemberById(Integer staffId) {
    String query = "DELETE FROM staff WHERE id = ?";
    try {
      queryRunner.update(query, staffId);
    } catch (SQLException e) {
      if (e.getMessage() != null
          && e.getMessage().startsWith("Integrity constraint violation")) {
        throw new InternalIntegrityConstraintException(
            "Staff member is participating at one of the tournaments and can not be deleted",
            e);
      }
      throw new InternalTechnicalException("Problem deleting staff member", e);
    }
  }

  /**
   * Deletes the given player from database.
   * 
   * @param playerId
   *          Id of the player to delete.
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public void deletePlayerById(Integer playerId) {
    String query = "DELETE FROM player WHERE id = ?";
    try {
      queryRunner.update(query, playerId);
    } catch (SQLException e) {
      if (e.getMessage() != null
          && e.getMessage().startsWith("Integrity constraint violation")) {
        throw new InternalIntegrityConstraintException(
            "Player is participating at one of the tournaments and can not be deleted",
            e);
      }
      throw new InternalTechnicalException("Problem deleting player", e);
    }
  }

  /**
   * Deletes all tournament data from the database
   * 
   * @param tournamentId
   *          Id of the tournament to delete
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public void deleteTournamentData(Integer tournamentId) {
    try {
      String deleteTournamentGamesQuery = "DELETE FROM tournament_game WHERE tournament_id = ?";
      queryRunner.update(deleteTournamentGamesQuery, tournamentId);
      String selectTournamentIdQuery = "SELECT id FROM tournament_team WHERE tournament_id = ?";
      List<TournamentTeam> tournamentTeams = queryRunner.query(
          selectTournamentIdQuery,
          new BeanListHandler<TournamentTeam>(TournamentTeam.class),
          tournamentId);
      if (tournamentTeams != null) {
        for (TournamentTeam tournamentTeam : tournamentTeams) {
          Integer tournamentTeamId = tournamentTeam.getId();
          deleteTournamentTeamData(tournamentTeamId);
        }
      }
      String deleteOfficialQuery = "DELETE FROM tournament_official WHERE tournament_id = ?";
      queryRunner.update(deleteOfficialQuery, tournamentId);
      String deleteTournamentQuery = "DELETE FROM tournament WHERE id = ?";
      queryRunner.update(deleteTournamentQuery, tournamentId);
    } catch (SQLException e) {
      throw new InternalTechnicalException("Problem deleting tournament data",
          e);
    }
  }

  /**
   * Deletes all data for the given tournament team
   * 
   * @param tournamentTeamId
   *          Id of tournament team to delete
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public void deleteTournamentTeamData(Integer tournamentTeamId) {
    String tournamentTeamAQuery = "SELECT * FROM tournament_game WHERE team_a_id = ?";
    String tournamentTeamBQuery = "SELECT * FROM tournament_game WHERE team_a_id = ?";
    List<Integer> params = new ArrayList<Integer>();
    params.add(tournamentTeamId);
    try {
      ResultSet rsTeamA = executeQuery(tournamentTeamAQuery, params);
      if (rsTeamA.next()) {
        throw new InternalIntegrityConstraintException(
            "Team is participating at one of the games and can not be deleted");
      }
      ResultSet rsTeamB = executeQuery(tournamentTeamBQuery, params);
      if (rsTeamB.next()) {
        throw new InternalIntegrityConstraintException(
            "Team is participating at one of the games and can not be deleted");
      }
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Problem deleting tournament team data", e);
    }
    String deleteTournamentPlayerQuery = "DELETE FROM tournament_player WHERE tournament_team_id = ?";
    String deleteTournamentStaffQuery = "DELETE FROM tournament_staff WHERE tournament_team_id = ?";
    String deleteTournamentTeamQuery = "DELETE FROM tournament_team WHERE id = ?";
    try {
      queryRunner.update(deleteTournamentPlayerQuery, tournamentTeamId);
      queryRunner.update(deleteTournamentStaffQuery, tournamentTeamId);
      queryRunner.update(deleteTournamentTeamQuery, tournamentTeamId);
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Problem deleting tournament team data", e);
    }
  }

  /**
   * Deletes tournament player
   * 
   * @param playerId
   *          Id of the player to be deleted
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public void deleteTournamentTeamPlayer(Integer playerId) {
    String deleteTournamentPlayerQuery = "DELETE FROM tournament_player WHERE id = ?";
    try {
      queryRunner.update(deleteTournamentPlayerQuery, playerId);
    } catch (SQLException e) {
      if (e.getMessage() != null
          && e.getMessage().startsWith("Integrity constraint violation")) {
        throw new InternalIntegrityConstraintException(
            "Player scored at one of the games and can not be deleted", e);
      }
      throw new InternalTechnicalException(
          "Problem deleting tournament player data", e);
    }
  }

  /**
   * Deletes tournament staff
   * 
   * @param staffId
   *          Id of the staff to be deleted
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public void deleteTournamentTeamStaff(Integer staffId) {
    String deleteTournamentStaffQuery = "DELETE FROM tournament_staff WHERE id = ?";
    try {
      queryRunner.update(deleteTournamentStaffQuery, staffId);
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Problem deleting tournament staff data", e);
    }
  }

  /**
   * Deletes the official from the given tournament
   * 
   * @param tournamentId
   *          Id of the tournament
   * @param officialId
   *          Id of the official
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public void deleteOfficialFromTournament(Integer tournamentId,
      Integer officialId) {
    String query = "DELETE FROM tournament_official WHERE tournament_id = ? AND official_id = ?";
    try {
      queryRunner.update(query, tournamentId, officialId);
    } catch (SQLException e) {
      if (e.getMessage() != null
          && e.getMessage().startsWith("Integrity constraint violation")) {
        throw new InternalIntegrityConstraintException(
            "Official is participating at one of the games and can not be deleted",
            e);
      }
      throw new InternalTechnicalException(
          "Problem deleting tournament official", e);
    }
  }

  /**
   * Deletes the tournament game from the database
   * 
   * @param tournamentGameId
   *          Id of the game to delete
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public void deleteTournamentGameById(Integer tournamentGameId) {
    String query = "DELETE FROM tournament_game WHERE id = ?";
    try {
      queryRunner.update(query, tournamentGameId);
    } catch (SQLException e) {
      throw new InternalTechnicalException("Problem deleting tournament game",
          e);
    }
  }

  /**
   * Deletes all admin data from the database.
   * 
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public void deleteAdminData() {
    try {
      String query = "DELETE FROM player WHERE admin_data = ?";
      queryRunner.update(query, true);
      query = "DELETE FROM staff WHERE admin_data = ?";
      queryRunner.update(query, true);
      query = "DELETE FROM team WHERE admin_data = ?";
      queryRunner.update(query, true);
      query = "DELETE FROM official WHERE admin_data = ?";
      queryRunner.update(query, true);
    } catch (SQLException e) {
      throw new InternalTechnicalException("Problem deleting admin data.", e);
    }
  }

  /**
   * Returns a configuration value for the given key.
   * 
   * @param key
   *          Configuration key.
   * @return Configuration value.
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public String getConfiguration(String key) {
    String query = "SELECT value FROM configuration WHERE key = ?";
    List<String> params = new ArrayList<String>();
    params.add(key);

    try {
      ResultSet rs = executeQuery(query, params);
      if (rs.next()) {
        return rs.getString("value");
      }
      return null;
    } catch (SQLException e) {
      throw new InternalTechnicalException(
          "Problem getting configuration from database.", e);
    }
  }

  /**
   * Tries to add the configuration to database. If configuration entry already
   * exists it then tries to update the existing configuration entry.
   * 
   * @param key
   *          Configuration key.
   * @param value
   *          Configuration value.
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  public void updateOrAddConfiguration(String key, String value) {
    String addQuery = "INSERT INTO configuration(value, key) VALUES (?, ?)";
    try {
      queryRunner.update(addQuery, value, key);
    } catch (SQLException e) {
      if (e.getMessage().startsWith("Unique constraint violation")) {
        String updateQuery = "UPDATE configuration SET value = ? WHERE key = ?";
        try {
          queryRunner.update(updateQuery, value, key);
        } catch (SQLException ex) {
          throw new InternalTechnicalException(
              "Problem updating configuration in database.", e);
        }
      }
      throw new InternalTechnicalException(
          "Problem adding configuration to database.", e);
    }
  }

  /**
   * Returns the maximum value of id key in the given table. Should be called
   * after each insert statement to obtain value of the generated key, because
   * HSQLDB does not support {@link Statement#getGeneratedKeys()} method.
   * 
   * @param tableName
   *          Name of the table
   * @return Max value of id key.
   */
  private int getMaxId(String tableName) throws SQLException {
    StringBuilder query = new StringBuilder("SELECT MAX(id) maxId FROM ");
    query.append(tableName);

    ResultSet rs = executeQuery(query.toString(), null);
    if (rs.next()) {
      return rs.getInt(1);
    }
    return -1;
  }

  /**
   * Executes a database query using the provided query and parameters and
   * returns the result set.
   * 
   * @param query
   *          Database query to execute.
   * @param parameters
   *          Parameters to use for the query.
   * @return Result set of the query.
   * @throws SQLException
   *           If problem with database occurs.
   */
  private ResultSet executeQuery(String query,
      List<? extends Object> parameters) throws SQLException {
    PreparedStatement prepStatement = createPreparedStatement(query,
        parameters);
    return prepStatement.executeQuery();
  }

  /**
   * Returns a prepared statement, created by applying the provided parameters
   * to the query.
   * 
   * @param query
   *          Query from which to create the prepared statement.
   * @param parameters
   *          Parameters to apply to the query.
   * @return Prepared statement created by applying the given parameters to the
   *         given query.
   * @throws InternalBusinessException
   *           If parameter type is not valid.
   * @throws SQLException
   *           If problems occur while applying parameters to query.
   */
  private PreparedStatement createPreparedStatement(String query,
      List<? extends Object> parameters) throws SQLException {
    PreparedStatement prepStatement = m_connection.prepareStatement(query);
    if (parameters != null) {
      for (int i = 0; i < parameters.size(); i++) {
        Object param = parameters.get(i);
        if (param == null) {
          prepStatement.setNull(i + 1, Types.VARCHAR);
        } else if (param instanceof Integer) {
          prepStatement.setInt(i + 1, (Integer) param);
        } else if (param instanceof String) {
          prepStatement.setString(i + 1, (String) param);
        } else if (param instanceof Date) {
          prepStatement.setDate(i + 1,
              new java.sql.Date(((Date) param).getTime()));
        } else if (param instanceof Float) {
          prepStatement.setFloat(i + 1, (Float) param);
        } else if (param instanceof Boolean) {
          prepStatement.setBoolean(i + 1, (Boolean) param);
        } else {
          throw new InternalBusinessException(
              "Invalid parameter type in prepared SQL statement: "
                  + param.getClass().getName());
        }
      }
    }
    return prepStatement;
  }

  /**
   * Inserts the required basic data to database. Ignores duplicates.
   * 
   * @throws InternalTechnicalException
   *           If problem with database occurs.
   */
  private void insertBasicData() {
    insertOfficialLevels();
    insertListOfCountries();
  }

  /**
   * Inserts predefined list of official levels.
   */
  private void insertOfficialLevels() {
    String query = "INSERT INTO official_level(level_name, level_description) VALUES (?, ?)";
    try {
      queryRunner.update(query, "ITO", "International Technical Official");
    } catch (SQLException e) {
      if (!e.getMessage().startsWith("Unique constraint")) {
        throw new InternalTechnicalException(e);
      }
    }
    try {
      queryRunner.update(query, "National", "National Level Referee");
    } catch (SQLException e) {
      if (!e.getMessage().startsWith("Unique constraint")) {
        throw new InternalTechnicalException(e);
      }
    }
    try {
      queryRunner.update(query, "Level I", "IBSA Level I Referee");
    } catch (SQLException e) {
      if (!e.getMessage().startsWith("Unique constraint")) {
        throw new InternalTechnicalException(e);
      }
    }
    try {
      queryRunner.update(query, "Level II", "IBSA Level II Referee");
    } catch (SQLException e) {
      if (!e.getMessage().startsWith("Unique constraint")) {
        throw new InternalTechnicalException(e);
      }
    }
    try {
      queryRunner.update(query, "Level III", "IBSA Level III Referee");
    } catch (SQLException e) {
      if (!e.getMessage().startsWith("Unique constraint")) {
        throw new InternalTechnicalException(e);
      }
    }
  }

  /**
   * Inserts predefined list of countries.
   */
  private void insertListOfCountries() {
    List<String> countries = DatabaseUtil.getListOfCountries();

    String query = "INSERT into country(country_name) VALUES(?)";
    for (String country : countries) {
      try {
        queryRunner.update(query, country);
      } catch (SQLException e) {
        if (!e.getMessage().startsWith("Unique constraint")) {
          throw new InternalTechnicalException(e);
        }

      }
    }
  }
}
